package ai.pentest;

import burp.IHttpRequestResponse;
import burp.IRequestInfo;
import burp.IExtensionHelpers;

import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.List;

public final class RequestFingerprint {

    private RequestFingerprint() {}

    public static boolean isLikelyStaticAsset(IRequestInfo requestInfo) {
        try {
            URL url = requestInfo.getUrl();
            String path = url.getPath().toLowerCase();
            if (path.endsWith(".js") || path.endsWith(".css") || path.endsWith(".png") || path.endsWith(".jpg") ||
                path.endsWith(".jpeg") || path.endsWith(".gif") || path.endsWith(".svg") || path.endsWith(".ico") ||
                path.endsWith(".woff") || path.endsWith(".woff2") || path.endsWith(".ttf") || path.endsWith(".eot") ||
                path.contains("/static/") || path.contains("/assets/") || path.contains("/fonts/") ||
                path.endsWith(".map")) {
                return true;
            }
            // Heuristic: GET with typical cacheable extensions or large numeric cache-busters in query
            if (requestInfo.getMethod().equalsIgnoreCase("GET")) {
                String query = url.getQuery();
                if (query != null && query.matches(".*(v=|version=|cache=)[0-9]{6,}.*")) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }

    public static String buildFingerprint(IExtensionHelpers helpers, IHttpRequestResponse messageInfo) {
        IRequestInfo requestInfo = helpers.analyzeRequest(messageInfo);
        URL url = requestInfo.getUrl();

        String path = url.getProtocol() + "://" + url.getHost() + ":" + url.getPort() + url.getPath();
        String method = requestInfo.getMethod();
        String contentType = getContentTypeHeader(requestInfo.getHeaders());

        byte[] body = getRequestBody(helpers, messageInfo);
        String bodyHash = hashFull(body); // full body hash to minimize collisions

        // Fingerprint: method + path + content-type + small body hash
        return method + " " + path + "|ct=" + contentType + "|bh=" + bodyHash;
    }

    public static String buildCompactSummary(IExtensionHelpers helpers, IHttpRequestResponse messageInfo) {
        IRequestInfo requestInfo = helpers.analyzeRequest(messageInfo);
        URL url = requestInfo.getUrl();

        StringBuilder sb = new StringBuilder();
        sb.append(requestInfo.getMethod()).append(" ").append(url.getPath());
        if (url.getQuery() != null) sb.append("?").append(url.getQuery());
        sb.append("\nHeaders: ");
        List<String> headers = requestInfo.getHeaders();
        int limit = Math.min(headers.size(), 8); // compact
        for (int i = 0; i < limit; i++) {
            String h = headers.get(i);
            if (h.toLowerCase().startsWith("authorization:")) continue; // do not echo creds
            sb.append(h).append("; ");
        }

        byte[] body = getRequestBody(helpers, messageInfo);
        if (body != null && body.length > 0) {
            String bodyStr = new String(body, StandardCharsets.UTF_8);
            bodyStr = bodyStr.length() > 300 ? bodyStr.substring(0, 300) + "..." : bodyStr;
            sb.append("\nBody: ").append(bodyStr);
            // Attempt JSON key extraction (with simple fallback parser)
            List<String> keys = extractJsonKeys(body);
            if (!keys.isEmpty()) {
                sb.append("\nJSON keys: ").append(String.join(", ", keys));
            }
        }
        return sb.toString();
    }

    // Attempt to extract top-level JSON keys without external deps; lightweight best-effort
    private static List<String> extractJsonKeys(byte[] body) {
        try {
            String s = new String(body, StandardCharsets.UTF_8).trim();
            if (!(s.startsWith("{") && s.contains(":"))) return java.util.Collections.emptyList();
            java.util.LinkedHashSet<String> keys = new java.util.LinkedHashSet<>();
            int depth = 0;
            boolean inStr = false;
            boolean esc = false;
            StringBuilder cur = new StringBuilder();
            for (int i = 0; i < s.length(); i++) {
                char c = s.charAt(i);
                if (inStr) {
                    if (esc) { cur.append(c); esc = false; continue; }
                    if (c == '\\') { esc = true; continue; }
                    if (c == '"') { inStr = false; }
                    else { cur.append(c); }
                } else {
                    if (c == '"' && depth == 1) { inStr = true; cur.setLength(0); }
                    else if (c == '{') depth++;
                    else if (c == '}') depth--;
                    else if (c == ':' && depth == 1) { keys.add(cur.toString()); }
                }
                if (keys.size() >= 12) break; // cap
            }
            return new java.util.ArrayList<>(keys);
        } catch (Exception e) {
            return java.util.Collections.emptyList();
        }
    }

    private static String getContentTypeHeader(List<String> headers) {
        for (String h : headers) {
            if (h.toLowerCase().startsWith("content-type:")) {
                return h.substring("content-type:".length()).trim().toLowerCase();
            }
        }
        return "";
    }

    public static byte[] getRequestBody(IExtensionHelpers helpers, IHttpRequestResponse messageInfo) {
        byte[] request = messageInfo.getRequest();
        IRequestInfo info = helpers.analyzeRequest(messageInfo);
        int bodyOffset = info.getBodyOffset();
        if (request == null || request.length <= bodyOffset) return new byte[0];
        byte[] body = new byte[request.length - bodyOffset];
        System.arraycopy(request, bodyOffset, body, 0, body.length);
        return body;
    }

    private static String hashFull(byte[] data) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(data);
            byte[] digest = md.digest();
            StringBuilder sb = new StringBuilder();
            for (byte b : digest) sb.append(String.format("%02x", b));
            return sb.toString();
        } catch (Exception e) {
            return "";
        }
    }
}


