package ai.pentest;

import burp.IBurpExtenderCallbacks;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.*;

/**
 * Minimal HTTP client wrapper for LLM calls with conservative defaults and in-memory cache.
 * This is a placeholder; plug in your org's endpoint and model.
 */
public class LLMClient {

    private final IBurpExtenderCallbacks callbacks;
    private final AuditLogger auditLogger;

    private volatile String apiKey = "";
    private volatile String model = "gpt-4o-mini";
    private final Object breakerLock = new Object();
    private int consecutiveFailures = 0;
    private long breakerUntilMs = 0L;

    // prompt->response cache (LRU)
    private final Map<String, String> cache = Collections.synchronizedMap(new LinkedHashMap<String, String>(64, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
            return size() > 128;
        }
    });

    public LLMClient(IBurpExtenderCallbacks callbacks, AuditLogger auditLogger) {
        this.callbacks = callbacks;
        this.auditLogger = auditLogger;
    }

    // Single-thread executor to avoid blocking UI threads and allow cancellations
    private final ExecutorService executor = Executors.newSingleThreadExecutor(r -> {
        Thread t = new Thread(r, "ai-llm-client");
        t.setDaemon(true);
        return t;
    });

    public void setApiKey(String apiKey) {
        this.apiKey = apiKey == null ? "" : apiKey.trim();
    }

    public boolean hasApiKey() {
        return apiKey != null && !apiKey.isEmpty();
    }

    public void setModel(String model) {
        if (model != null && !model.trim().isEmpty()) this.model = model.trim();
    }
    
    public void clearCache() {
        synchronized (cache) {
            cache.clear();
        }
    }
    
    public int getCacheSize() {
        synchronized (cache) {
            return cache.size();
        }
    }

    public String completeWithCache(String prompt, int maxTokens) {
        if (prompt == null || prompt.isEmpty()) return null;
        synchronized (cache) {
            if (cache.containsKey(prompt)) return cache.get(prompt);
        }
        String resp = complete(prompt, maxTokens);
        if (resp != null) {
            synchronized (cache) { cache.put(prompt, resp); }
        }
        return resp;
    }

    public CompletableFuture<String> completeAsync(String prompt, int maxTokens) {
        CompletableFuture<String> future = new CompletableFuture<>();
        executor.submit(() -> {
            try {
                String result = complete(prompt, maxTokens);
                future.complete(result);
            } catch (Exception e) {
                future.completeExceptionally(e);
            }
        });
        return future;
    }

    public CompletableFuture<String> ping() {
        if (!hasApiKey()) {
            CompletableFuture<String> future = new CompletableFuture<>();
            future.completeExceptionally(new IllegalStateException("No API key configured"));
            return future;
        }
        String prompt = "You are a connection check. Reply with the single word PONG.";
        return completeAsync(prompt, 8);
    }

    // Placeholder implementation using HttpURLConnection.
    // Replace URL and payload to match your provider (e.g., OpenAI gpt-4o-mini / gpt-40-mini).
    public String complete(String prompt, int maxTokens) {
        if (!hasApiKey()) return null;
        if (isCircuitOpen()) {
            callbacks.printOutput("LLM circuit open; skipping network calls and using local signals only.");
            return null;
        }
        int attempts = 0;
        int maxAttempts = 2;

        while (attempts < maxAttempts) {
            attempts++;
            HttpURLConnection conn = null;
            try {
                URL url = new URL("https://api.openai.com/v1/chat/completions"); // replace as needed
                conn = (HttpURLConnection) url.openConnection();
                conn.setRequestMethod("POST");
                conn.setRequestProperty("Content-Type", "application/json");
                conn.setRequestProperty("Authorization", "Bearer " + apiKey);
                conn.setConnectTimeout(10000);  // 10 seconds for connection establishment
                conn.setReadTimeout(60000);  // 60 seconds to accommodate longer LLM response times
                conn.setDoOutput(true);

                String currentModel = this.model; // "gpt-4o-mini" or "gpt-40-mini"
                int cappedMaxTokens = Math.max(128, Math.min(maxTokens, 800));
                String json = "{\n" +
                        "  \"model\": \"" + currentModel + "\",\n" +
                        "  \"messages\": [{\"role\": \"user\", \"content\": " + toJsonString(prompt) + "}],\n" +
                        "  \"max_tokens\": " + cappedMaxTokens + ",\n" +
                        "  \"temperature\": 0.2\n" +
                        "}";

                try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {
                    wr.write(json.getBytes(StandardCharsets.UTF_8));
                }

                int code = conn.getResponseCode();
                BufferedReader reader = new BufferedReader(new InputStreamReader(
                        code >= 200 && code < 300 ? conn.getInputStream() : conn.getErrorStream(),
                        StandardCharsets.UTF_8));
                StringBuilder sb = new StringBuilder();
                char[] buffer = new char[8192];
                int read;
                while ((read = reader.read(buffer, 0, buffer.length)) != -1) {
                    sb.append(buffer, 0, read);
                }
                reader.close();

                if (code >= 200 && code < 300) {
                    String content = extractContentFromOpenAI(sb.toString());
                    // Always log successful responses to Burp output
                    if (content != null && !content.trim().isEmpty()) {
                        callbacks.printOutput("LLM Response: " + content);
                    } else {
                        callbacks.printOutput("LLM Response: (empty)");
                    }
                    auditLogger.logEvent("llm_ok", "", "len=" + prompt.length(), "len=" + (content == null ? 0 : content.length()));
                    recordSuccess();
                    return content;
                } else {
                    recordFailure();
                    callbacks.printError("LLM error: HTTP " + code + " - " + sb);
                }
            } catch (Exception e) {
                callbacks.printError("LLM request failed: " + e.getMessage());
                recordFailure();
            } finally {
                if (conn != null) conn.disconnect();
            }
        }
        return null;
    }

    private boolean isCircuitOpen() {
        synchronized (breakerLock) {
            long now = System.currentTimeMillis();
            if (breakerUntilMs > now) return true;
            return false;
        }
    }

    private void recordFailure() {
        synchronized (breakerLock) {
            consecutiveFailures++;
            if (consecutiveFailures >= 3) {
                breakerUntilMs = System.currentTimeMillis() + 60_000L; // 60s
                consecutiveFailures = 0; // reset counter once tripped
            }
        }
    }

    private void recordSuccess() {
        synchronized (breakerLock) {
            consecutiveFailures = 0;
            breakerUntilMs = 0L;
        }
    }

    private String toJsonString(String s) {
        if (s == null) return "\"\"";
        StringBuilder sb = new StringBuilder();
        sb.append('"');
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            switch (c) {
                case '\\':
                    sb.append("\\\\");
                    break;
                case '"':
                    sb.append("\\\"");
                    break;
                case '\n':
                    sb.append("\\n");
                    break;
                case '\r':
                    sb.append("\\r");
                    break;
                case '\t':
                    sb.append("\\t");
                    break;
                case '\b':
                    sb.append("\\b");
                    break;
                case '\f':
                    sb.append("\\f");
                    break;
                default:
                    if (c < 0x20) {
                        // Escape other control characters as Unicode escape sequence (\\uXXXX format)
                        sb.append("\\u");
                        String hex = Integer.toHexString((int) c);
                        for (int j = hex.length(); j < 4; j++) {
                            sb.append('0');
                        }
                        sb.append(hex);
                    } else {
                        sb.append(c);
                    }
                    break;
            }
        }
        sb.append('"');
        return sb.toString();
    }

    // Minimal JSON extraction to avoid external deps; replace with proper JSON in production
    private String extractContentFromOpenAI(String json) {
        if (json == null || json.isEmpty()) return null;
        try {
            int key = json.indexOf("\"content\"");
            if (key < 0) return null;
            int colon = json.indexOf(':', key);
            if (colon < 0) return null;
            int startQuote = json.indexOf('"', colon + 1);
            if (startQuote < 0) return null;
            StringBuilder out = new StringBuilder();
            boolean esc = false;
            for (int i = startQuote + 1; i < json.length(); i++) {
                char c = json.charAt(i);
                if (esc) { out.append(c); esc = false; }
                else if (c == '\\') { esc = true; }
                else if (c == '"') { break; }
                else { out.append(c); }
            }
            String raw = out.toString();
            return unescapeJsonLoop(raw);
        } catch (Exception e) {
            return null;
        }
    }

    private String unescapeJsonLoop(String s) {
        if (s == null) return null;
        String cur = s;
        while (true) {
            String next = cur
                    .replace("\\n", "\n")
                    .replace("\\r", "\r")
                    .replace("\\t", "\t")
                    .replace("\\\"", "\"")
                    .replace("\\\\", "\\");
            if (next.equals(cur)) break;
            cur = next;
        }
        return cur;
    }

}


