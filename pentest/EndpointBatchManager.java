package ai.pentest;

import burp.IHttpRequestResponse;
import burp.IRequestInfo;
import burp.IExtensionHelpers;

import java.net.URL;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

/**
 * Manages endpoint batching: groups related endpoints (5 per batch) that build towards vulnerabilities.
 * Implements cost control with max endpoints per session while ensuring full coverage.
 */
public class EndpointBatchManager {
    
    private static final int BATCH_SIZE = 5;
    private static final int MAX_ENDPOINTS_PER_SESSION = 100; // Prevents UI slowdown
    private static final long BATCH_TIMEOUT_MS = 2000; // 2s to collect related endpoints
    
    private final IExtensionHelpers helpers;
    private final Queue<EndpointEntry> pendingQueue = new ConcurrentLinkedQueue<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1, r -> {
        Thread t = new Thread(r, "endpoint-batch-scheduler");
        t.setDaemon(true);
        return t;
    });
    
    private volatile int processedCount = 0;
    private volatile double scoringThreshold = 0.6;
    
    public static class EndpointEntry {
        public final IHttpRequestResponse messageInfo;
        public final IRequestInfo requestInfo;
        public final String endpointKey;
        public final String fingerprint;
        public final long timestamp;
        public final List<ai.pentest.ptt.PTTNode> pttNodes;
        public final String vulnerabilityCategory; // e.g., "BOLA", "BrokenAuth", etc.
        
        public EndpointEntry(IHttpRequestResponse msg, IRequestInfo req, String key, String fp, 
                            List<ai.pentest.ptt.PTTNode> nodes, String vulnCat) {
            this.messageInfo = msg;
            this.requestInfo = req;
            this.endpointKey = key;
            this.fingerprint = fp;
            this.timestamp = System.currentTimeMillis();
            this.pttNodes = nodes != null ? new ArrayList<>(nodes) : new ArrayList<>();
            this.vulnerabilityCategory = vulnCat;
        }
    }
    
    public static class Batch {
        public final List<EndpointEntry> endpoints;
        public final String commonVulnerability; // Primary vulnerability this batch targets
        
        public Batch(List<EndpointEntry> endpoints, String vuln) {
            this.endpoints = new ArrayList<>(endpoints);
            this.commonVulnerability = vuln;
        }
    }
    
    public EndpointBatchManager(IExtensionHelpers helpers) {
        this.helpers = helpers;
        // Start periodic batch processing
        scheduler.scheduleWithFixedDelay(this::processBatches, 3, 3, TimeUnit.SECONDS);
    }
    
    public void setScoringThreshold(double threshold) {
        this.scoringThreshold = Math.max(0.0, Math.min(1.0, threshold));
    }
    
    public double getScoringThreshold() {
        return scoringThreshold;
    }
    
    /**
     * Add endpoint to queue for batch processing.
     * Returns true if accepted, false if session limit reached.
     */
    public boolean queueEndpoint(IHttpRequestResponse messageInfo, IRequestInfo requestInfo,
                                 String endpointKey, String fingerprint,
                                 List<ai.pentest.ptt.PTTNode> pttNodes) {
        if (processedCount >= MAX_ENDPOINTS_PER_SESSION) {
            return false; // Session limit reached
        }
        
        String vulnCategory = inferVulnerabilityCategory(requestInfo, pttNodes);
        EndpointEntry entry = new EndpointEntry(messageInfo, requestInfo, endpointKey, 
                                               fingerprint, pttNodes, vulnCategory);
        
        pendingQueue.offer(entry);
        return true;
    }
    
    /**
     * Group endpoints by vulnerability category and path similarity.
     * Returns batches of up to 5 related endpoints.
     */
    private List<Batch> groupEndpointsIntoBatches(List<EndpointEntry> entries) {
        if (entries.isEmpty()) return Collections.emptyList();
        
        // Group by vulnerability category first
        Map<String, List<EndpointEntry>> byVuln = entries.stream()
            .collect(Collectors.groupingBy(e -> e.vulnerabilityCategory != null ? 
                                          e.vulnerabilityCategory : "General"));
        
        List<Batch> batches = new ArrayList<>();
        
        for (Map.Entry<String, List<EndpointEntry>> vulnGroup : byVuln.entrySet()) {
            List<EndpointEntry> group = vulnGroup.getValue();
            
            // Further group by path similarity (same base path)
            Map<String, List<EndpointEntry>> byPath = group.stream()
                .collect(Collectors.groupingBy(e -> {
                    String path = e.requestInfo.getUrl().getPath();
                    // Extract base path (first 2-3 segments)
                    String[] parts = path.split("/");
                    if (parts.length >= 3) {
                        return parts[0] + "/" + parts[1] + "/" + parts[2];
                    } else if (parts.length == 2) {
                        return parts[0] + "/" + parts[1];
                    }
                    return path;
                }));
            
            for (List<EndpointEntry> pathGroup : byPath.values()) {
                // Split into batches of 5
                for (int i = 0; i < pathGroup.size(); i += BATCH_SIZE) {
                    int end = Math.min(i + BATCH_SIZE, pathGroup.size());
                    List<EndpointEntry> batchEndpoints = pathGroup.subList(i, end);
                    batches.add(new Batch(batchEndpoints, vulnGroup.getKey()));
                }
            }
        }
        
        return batches;
    }
    
    /**
     * Infer primary vulnerability category from endpoint and PTT nodes.
     */
    private String inferVulnerabilityCategory(IRequestInfo req, List<ai.pentest.ptt.PTTNode> nodes) {
        if (nodes == null || nodes.isEmpty()) {
            return inferFromPath(req);
        }
        
        // Find highest scoring vulnerability category
        Map<String, Double> categoryScores = new HashMap<>();
        for (ai.pentest.ptt.PTTNode node : nodes) {
            String title = node.getTitle();
            double score = node.getScore();
            
            if (title.contains("BOLA")) {
                categoryScores.put("BOLA", Math.max(categoryScores.getOrDefault("BOLA", 0.0), score));
            } else if (title.contains("Broken Authentication")) {
                categoryScores.put("BrokenAuth", Math.max(categoryScores.getOrDefault("BrokenAuth", 0.0), score));
            } else if (title.contains("Security Misconfiguration")) {
                categoryScores.put("SecurityMisconfig", Math.max(categoryScores.getOrDefault("SecurityMisconfig", 0.0), score));
            } else if (title.contains("SSRF")) {
                categoryScores.put("SSRF", Math.max(categoryScores.getOrDefault("SSRF", 0.0), score));
            } else if (title.contains("Excessive Data Exposure")) {
                categoryScores.put("ExcessiveData", Math.max(categoryScores.getOrDefault("ExcessiveData", 0.0), score));
            }
        }
        
        if (!categoryScores.isEmpty()) {
            return categoryScores.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse("General");
        }
        
        return inferFromPath(req);
    }
    
    private String inferFromPath(IRequestInfo req) {
        String path = req.getUrl().getPath().toLowerCase();
        if (path.contains("/user") || path.contains("/account") || path.matches(".*/\\d+.*")) {
            return "BOLA";
        } else if (path.contains("/login") || path.contains("/auth")) {
            return "BrokenAuth";
        } else if (path.contains("/admin")) {
            return "FunctionLevelAuth";
        } else if (path.contains("?url=") || path.contains("callback=")) {
            return "SSRF";
        }
        return "General";
    }
    
    /**
     * Process pending endpoints into batches.
     * Called periodically by scheduler.
     */
    private void processBatches() {
        if (pendingQueue.isEmpty()) return;
        
        // Collect endpoints that are ready (older than timeout or queue is full enough)
        List<EndpointEntry> ready = new ArrayList<>();
        long now = System.currentTimeMillis();
        
        while (!pendingQueue.isEmpty() && ready.size() < BATCH_SIZE * 2) {
            EndpointEntry entry = pendingQueue.poll();
            if (entry != null) {
                if (now - entry.timestamp >= BATCH_TIMEOUT_MS || ready.size() >= BATCH_SIZE) {
                    ready.add(entry);
                } else {
                    // Too recent, put back
                    pendingQueue.offer(entry);
                    break;
                }
            }
        }
        
        if (ready.isEmpty()) return;
        
        // Group into batches
        List<Batch> batches = groupEndpointsIntoBatches(ready);
        
        // Notify listener (will be set by AIPentestExtender)
        for (Batch batch : batches) {
            if (batchListener != null) {
                batchListener.onBatchReady(batch);
            }
        }
    }
    
    public interface BatchListener {
        void onBatchReady(Batch batch);
    }
    
    private BatchListener batchListener;
    
    public void setBatchListener(BatchListener listener) {
        this.batchListener = listener;
    }
    
    public void incrementProcessed() {
        processedCount++;
    }
    
    public int getProcessedCount() {
        return processedCount;
    }
    
    public int getPendingCount() {
        return pendingQueue.size();
    }
    
    public void resetSession() {
        processedCount = 0;
        pendingQueue.clear();
    }
    
    public void shutdown() {
        scheduler.shutdown();
    }
}

