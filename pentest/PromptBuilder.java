package ai.pentest;

import burp.IRequestInfo;

import java.net.URL;
import java.util.ArrayList;
import java.util.List;

/**
 * Builds compact PTT (Pentest Tree of Thought) nodes and prompts.
 * Focused on OWASP API Top 10 (2023) passive heuristics.
 */
public class PromptBuilder {

    public static class PTTNode {
        public final String urlPath;
        public final String method;
        public final List<String> parameterHints;
        public final List<String> heuristics;
        public final String summary;

        public PTTNode(String urlPath, String method, List<String> parameterHints, List<String> heuristics, String summary) {
            this.urlPath = urlPath;
            this.method = method;
            this.parameterHints = parameterHints;
            this.heuristics = heuristics;
            this.summary = summary;
        }
    }

    public PTTNode buildPTTNode(IRequestInfo requestInfo, String summary) {
        URL url = requestInfo.getUrl();
        String path = url.getPath();
        String method = requestInfo.getMethod();

        List<String> hints = inferParameterHints(url.getQuery());
        List<String> heuristics = inferHeuristics(path, method);
        return new PTTNode(path, method, hints, heuristics, summary);
    }

    public String buildPassivePrompt(PTTNode node) {
        StringBuilder sb = new StringBuilder();
        sb.append("You are an API security pentest assistant. Perform FULL vulnerability analysis.\n");
        sb.append("Rules: be concise, no active attacks. Reason step-by-step on vulnerability chains.\n");
        sb.append("Target: OWASP API Top 10 (2023).\n");
        sb.append("Analyze ALL provided evidence, including low-confidence signals.\n");
        sb.append("Respond with short bullets: risk, evidence, check, mitigation.\n\n");
        sb.append("Endpoint: ").append(node.method).append(" ").append(node.urlPath).append("\n");
        if (!node.parameterHints.isEmpty()) sb.append("Parameters: ").append(String.join(", ", node.parameterHints)).append("\n");
        if (!node.heuristics.isEmpty()) sb.append("Heuristics: ").append(String.join(", ", node.heuristics)).append("\n");
        sb.append("Summary:\n").append(node.summary).append("\n\n");
        sb.append("Output format (max 6 bullets):\n");
        sb.append("- Finding (risk)\n- Evidence (from headers/body/structure)\n- Safe check (passive)\n- If high confidence: tentative\n- Mitigation\n- OWASP category\n");
        return sb.toString();
    }
    
    /**
     * Build prompt for batch analysis (multiple related endpoints).
     */
    public String buildBatchPrompt(java.util.List<PTTNode> nodes, String vulnerabilityCategory) {
        StringBuilder sb = new StringBuilder();
        sb.append("You are an API security pentest assistant. Perform FULL vulnerability analysis on a batch of related endpoints.\n");
        sb.append("Rules: be concise, no active attacks. Reason step-by-step on vulnerability chains.\n");
        sb.append("Target: OWASP API Top 10 (2023).\n");
        sb.append("Primary focus: ").append(vulnerabilityCategory).append("\n");
        sb.append("Analyze ALL provided evidence, including low-confidence signals.\n");
        sb.append("Look for patterns across endpoints that build towards a vulnerability.\n\n");
        
        for (int i = 0; i < nodes.size(); i++) {
            PTTNode node = nodes.get(i);
            sb.append("Endpoint ").append(i + 1).append(": ").append(node.method).append(" ").append(node.urlPath).append("\n");
            if (!node.parameterHints.isEmpty()) sb.append("  Parameters: ").append(String.join(", ", node.parameterHints)).append("\n");
            if (!node.heuristics.isEmpty()) sb.append("  Heuristics: ").append(String.join(", ", node.heuristics)).append("\n");
            sb.append("  Summary: ").append(node.summary).append("\n\n");
        }
        
        sb.append("Output format (per endpoint or cross-endpoint findings):\n");
        sb.append("- Finding (risk)\n- Evidence (from headers/body/structure across endpoints)\n- Safe check (passive)\n- If high confidence: tentative\n- Mitigation\n- OWASP category\n");
        return sb.toString();
    }

    public String buildPassivePrompt(PTTNode node, java.util.List<ai.pentest.ptt.PTTNode> pttEvaluated) {
        String base = buildPassivePrompt(node);
        StringBuilder inj = new StringBuilder();
        
        // Include ALL evidence, even low scores (as per user requirement)
        // Sort by score descending for better context, but include all
        List<ai.pentest.ptt.PTTNode> sorted = new ArrayList<>(pttEvaluated);
        sorted.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));
        
        for (ai.pentest.ptt.PTTNode n : sorted) {
            // Include all evidence, not just high-confidence
            StringBuilder evidenceStr = new StringBuilder();
            if (!n.getEvidence().isEmpty()) {
                evidenceStr.append(" evidence:[");
                for (int i = 0; i < n.getEvidence().size() && i < 3; i++) {
                    if (i > 0) evidenceStr.append(", ");
                    evidenceStr.append(sanitize(n.getEvidence().get(i)));
                }
                evidenceStr.append("]");
            }
            inj.append(n.getTitle())
               .append(":score=").append(String.format(java.util.Locale.ROOT, "%.2f", n.getScore()))
               .append(evidenceStr.toString())
               .append("; ");
        }
        
        if (inj.length() > 0) {
            return base + "\nPTT Evidence (all scores included): [" + inj.toString().trim() + "]\n" +
                   "Perform full vulnerability analysis considering all evidence above.\n";
        }
        return base;
    }

    private String sanitize(String s) {
        if (s == null) return "";
        return s.replace('\n', ' ').replace("\r", " ").trim();
    }

    private List<String> inferParameterHints(String query) {
        List<String> hints = new ArrayList<>();
        if (query == null || query.isEmpty()) return hints;
        if (query.matches(".*id=\\d+.*")) hints.add("numeric id in query");
        if (query.toLowerCase().contains("token=")) hints.add("token param");
        if (query.toLowerCase().contains("file=")) hints.add("file param");
        if (query.length() > 120) hints.add("long query");
        return hints;
    }

    private List<String> inferHeuristics(String path, String method) {
        List<String> heuristics = new ArrayList<>();
        String p = path.toLowerCase();
        if (p.contains("/admin") || p.contains("/internal")) heuristics.add("admin/internal path");
        if (p.contains("/upload") || p.contains("/imports")) heuristics.add("upload/import endpoint");
        if (p.matches(".*/\\d+(/.*)?")) heuristics.add("numeric id in path");
        if (method.equalsIgnoreCase("PUT") || method.equalsIgnoreCase("PATCH") || method.equalsIgnoreCase("DELETE"))
            heuristics.add("state-changing method");
        return heuristics;
    }
}


