package ai.pentest;

import ai.pentest.ptt.PTTCache;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

/**
 * Centralized memory/history manager for the extension.
 * Tracks and clears all caches, history, and session data.
 */
public class MemoryManager {
    
    private RequestCache requestCache;
    private PTTCache pttCache;
    private LLMClient llmClient;
    private EndpointBatchManager batchManager;
    private AuditLogger auditLogger;
    private final List<FindingRecord> findings = Collections.synchronizedList(new ArrayList<>());
    
    public MemoryManager() {
    }
    
    public void setRequestCache(RequestCache requestCache) {
        this.requestCache = requestCache;
    }
    
    public void setPTTCache(PTTCache pttCache) {
        this.pttCache = pttCache;
    }
    
    public void setLLMClient(LLMClient llmClient) {
        this.llmClient = llmClient;
    }
    
    public void setBatchManager(EndpointBatchManager batchManager) {
        this.batchManager = batchManager;
    }
    
    public void setAuditLogger(AuditLogger auditLogger) {
        this.auditLogger = auditLogger;
    }
    
    /**
     * Clear all extension memory/history to start a new test session.
     */
    public void clearAllHistory() {
        if (requestCache != null) {
            requestCache.clear();
        }
        
        if (pttCache != null) {
            pttCache.clear();
        }
        
        if (llmClient != null) {
            llmClient.clearCache();
        }
        
        if (batchManager != null) {
            batchManager.resetSession();
        }
        
        if (auditLogger != null) {
            auditLogger.flush(); // Flush current logs
            // Note: AuditLogger writes to file, so we can't "clear" it, but we can flush
        }

        synchronized (findings) {
            findings.clear();
        }
    }
    
    /**
     * Get statistics about current memory usage.
     */
    public MemoryStats getStats() {
        MemoryStats stats = new MemoryStats();
        
        if (batchManager != null) {
            stats.processedEndpoints = batchManager.getProcessedCount();
            stats.pendingEndpoints = batchManager.getPendingCount();
        }
        
        if (llmClient != null) {
            stats.llmCacheSize = llmClient.getCacheSize();
        }

        synchronized (findings) {
            stats.findingsCount = findings.size();
        }
        
        return stats;
    }

    public void recordFinding(String title, String preview) {
        if ((title == null || title.trim().isEmpty()) && (preview == null || preview.trim().isEmpty())) {
            return;
        }
        FindingRecord record = new FindingRecord(
                title == null ? "Tentative Finding" : title.trim(),
                preview == null ? "" : preview.trim(),
                System.currentTimeMillis()
        );
        synchronized (findings) {
            findings.add(record);
            // cap history to last 200 entries to avoid unbounded growth
            if (findings.size() > 200) {
                int removeCount = findings.size() - 200;
                Iterator<FindingRecord> it = findings.iterator();
                while (removeCount > 0 && it.hasNext()) {
                    it.next();
                    it.remove();
                    removeCount--;
                }
            }
        }
    }

    public List<FindingRecord> getRecentFindings() {
        synchronized (findings) {
            return new ArrayList<>(findings);
        }
    }
    
    public static class MemoryStats {
        public int processedEndpoints = 0;
        public int pendingEndpoints = 0;
        public int llmCacheSize = 0;
        public int findingsCount = 0;
    }

    public static class FindingRecord {
        public final String title;
        public final String preview;
        public final long timestampMs;

        public FindingRecord(String title, String preview, long timestampMs) {
            this.title = title;
            this.preview = preview;
            this.timestampMs = timestampMs;
        }
    }
}

